#+title: Пасрер российских адресов
#+subtitle: ru-address-parser
#+startup: content

* Оглавление                                                            :toc:
- [[#вводная][Вводная]]
- [[#сборка-проекта-и-запуск][Сборка проекта и запуск]]
  - [[#через-dockerfile][Через Dockerfile]]
  - [[#в-консоли][В консоли]]
- [[#описание-http-сервера][Описание HTTP-сервера]]
- [[#описание-консольной-утилиты][Описание консольной утилиты]]
- [[#описание-формата-результатов][Описание формата результатов]]
- [[#что-предполагается-дальше][Что предполагается дальше?]]
- [[#замечания][Замечания]]

* Вводная

  Проект ru-address-parser написан в рамках изучения языка
  Haskell. Цель проекта - получить из строки текста составляющие
  почтового адреса, как то: область, город, район и т.д. до номера
  дома.

  /Идеи и приемы по созданию аппликативного парсера были взяты из этой презентации:/ \\
  /[[https://speakerdeck.com/dmitrytsepelev/applikativnoie-proghrammirovaniie-ili-kak-parsit-sql-na-chistom-haskell][Аппликативное программирование или как парсить SQL на чистом Haskell]]/
  /Спасибо автору за четко и ясно изложенный материал!/

  Пример текста с адресом дома: \\
  *г Москва внутригородская территория поселение Московский г.Московский 1-й микрорайон 1с2*

  И сразу пример результата по его разбору:
  #+begin_src json
  {
      "house": [
          "дом 1",
          "строение 2"
      ],
      "houseInt": 1,
      "realTown": "город Московский",
      "street": "1-й микрорайон",
      "subtown": [
          {
              "name": "innerTownTerritory",
              "value": "внутригородская территория"
          },
          {
              "name": "colony",
              "value": "поселение Московский"
          },
          {
              "name": "town",
              "value": "город Московский"
          }
      ],
      "town": "город Москва"
  }
  #+end_src
  (Подробнее структура результата будет описана ниже.)

  Проект компилируется в два приложения:
  1. =ru-address-parser= - консольная утилита (читает строки из stdin
     и пишет результат в stdout),
  2. =ru-address-parser-server= - HTTP-сервер.
  Оба приложения можно собрать в docker-образе (Dockerfile
  прилагается).

* Сборка проекта и запуск

** Через Dockerfile

   Если нет желания тянуть себе на машину хаскеллиную кухню, то проще
   всего собрать docker и запустить приложение из него.

   Для этого:
   1. Войдите в директорию проекта.
   2. Запустите команду
      : make docker-build
      или ее аналог
      : docker build -t ru-address-parser .
   В результате будет собран docker-образ с именем "ru-address-parser".

   Для запуска HTTP-сервера на порту 8000 запустите следующую команду:
   : make docker-run
   или ее аналог
   : docker run --rm -it --name ru-address-parser -p 8000:8000 ru-address-parser

   Теперь можно посылать из браузера REST-запросы типа:
   : http://localhost:8000/parse?pretty&meditative&q=ул.Зеленая,д1
   и смотреть результат.

   Подробнее URL-параметры запроса будут описаны ниже.

** В консоли

   Для сборки проекта в консоли в системе должны быть установлены
   следующие два приложения:
   1. =ghc= - компилятор Haskell,
   2. =cabal= - сборщик проектов.
   Установить их можно, как рекомендуют на [[https://www.haskell.org/downloads/][официальной странице]], то
   есть, [[https://www.haskell.org/ghcup/][так]].

   Собираем проект:
   1. Войдите в директорию проекта.
   2. Запустите команду
      : make build
      или ее аналог
      : cabal build
      После этого запустится компиляция проекта.

   Проверить работу HTTP-сервера можно запустив команду
   : make run-server
   или ее аналог
   : cabal run ru-address-parser-server -- -p 8000
   Сервер =ru-address-parser-server= будет запущен.

   Проверить работу консольной утилиты можно запустив команду
   : make run
   или ее аналог
   : cabal run ru-address-parser -- --pretty
   Утилита =ru-address-parser= будет запущена. Можно вводить адреса и
   смотреть результат после нажатия Enter.

   Подробнее о параметрах утилиты будет описано ниже.

   Чтобы установить утилиты в систему, запустите команду
   : make install
   или ее аналог
   : cabal install

* Описание HTTP-сервера

  HTTP-сервер может быть полезен в сервисах, где пользователь вводит
  адрес своего дома или улицы, и этот адрес надо как-то обработать.

  Запуск HTTP-сервера делается командой
  : ru-address-parser-server -p 8000
  У утилиты =ru-address-parser-server= есть единственный
  необязательный параметр: =-p= или =--port=, через который можно
  указать номер слушающего порта. По-умолчанию он равен 8000.

  Запросы на разбор адресов делаются GET-запросом
  : GET /parse?q=текст_адреса
  Например на локальной машине он будет выглядеть так:
  : GET http://localhost:8000/parse?q=Прямой проспект д1а

  В запросе могут быть указаны следующие параметры:

  #+caption: URL-параметры запроса
  | Параметр   | Описание                        | Пример        |
  |------------+---------------------------------+---------------|
  | q          | Текст запроса.                  | q=Забелина,16 |
  | pretty     | Делает ответ форматированным.   | pretty        |
  | meditative | Подбор лучшего варианта ответа. | meditative    |

  Пример:
  : GET http://localhost:8000/parse?q=Забелина,16&pretty&meditative

  Немного пояснений про параметр =meditative=. Если его не указывать,
  то парсер будет выбирать первый адрес, который удалось распознать из
  параметра =q= (такой вариант работает быстрее, но надо быть
  уверенным, что в строке запроса ничего постороннего кроме адреса не
  присутствует). Если же параметр =meditative= указан, то парсер будет
  выдавать ответ лучший по его мнению, но работать будет медленней.

  Для примера распознаем адрес: \\
  *Солнечная б/н г Цветочный ул Огуречная 1к4*

  Запрос без параметра =meditative=:
  : GET http://localhost:8000/parse?q=Солнечная б/н г Цветочный ул Огуречная 1к4
  Ответ парсера:
  #+begin_src json
  {
    "house": [
      "дом б/н"
    ],
    "street": "Солнечная"
  }
  #+end_src

  Тот же запрос, но с параметром =meditative=:
  : GET http://localhost:8000/parse?meditative&q=Солнечная б/н г Цветочный ул Огуречная 1к4
  Ответ парсера:
  #+begin_src json
  {
    "house": [
      "дом 1",
      "корпус 4"
    ],
    "houseInt": 1,
    "realTown": "город Цветочный",
    "street": "улица Огуречная",
    "town": "город Цветочный"
  }
  #+end_src

* Описание консольной утилиты

  Консольная утилита =ru-address-parser= предназначена в целом для
  потоковой обработки адресов. Это может быть полезно для задачи,
  когда имеется полный набор текстов адресов, но каждый из них записан
  в одну строку, и нужно из этого получить словари с названием
  городов, районов, улиц и прочего.

  Утилита читает строки из стандартного входного потока (stdin), а
  результаты выдает в стандартный выходной поток (stdout).

  Если у вас есть текстовый файл со строками адресов (addresses.txt),
  то утилитой =ru-address-parser= можно воспользоваться так:
  : cat addresses.txt | ru-address-parser > parsed.jsons
  Результатом будут строки, в каждой из которых будет JSON-объект.

  Чтобы поменять формат вывода, есть следующие необязательные
  параметры командной строки:

  #+caption: Параметры командной строки
  | Параметр     | Описание                                        |
  |--------------+-------------------------------------------------|
  | -p, --pretty | JSON выводится в отформатированном виде.        |
  | -j, --json   | Все результаты объединяются в один JSON-список. |

* Описание формата результатов

  Немного о том, как работает парсер. На данный момент он не
  использует никаких словарей с названиями объектов типа улиц, городов
  и т.п. (это предполагается сделать в дальнейшем). Парсер при разборе
  ориентируется только на ключевые слова и знаки препинания (точка и
  запятая). Запятые можно опускать, ориентир на них идет только в
  случае неоднозначности (например, чтобы разделить рядом стоящие
  названия).

  Результат разбора одного адреса - это JSON-объект со следующими
  полями:

  #+caption: Описание структуры результата
  | Поле      | Описание                                                                                                                                       |
  |-----------+------------------------------------------------------------------------------------------------------------------------------------------------|
  | country   | Название страны (сейчас только Российская Федерация).                                                                                          |
  | subCounry | Массив объектов типа "республика" или "область".                                                                                               |
  | town      | Название основного города.                                                                                                                     |
  | subTown   | Массив объектов типа "район", "округ", "деревня", "город" и т.д..                                                                              |
  | street    | Название улицы.                                                                                                                                |
  | house     | Массив объектов, из которых состоит номер дома ("дом", "корпус" и т.д.).                                                                       |
  |-----------+------------------------------------------------------------------------------------------------------------------------------------------------|
  | realTown  | Сюда заносится объект из поля subTown, как наиболее интересный населенный пункт. Если такового не находится, то значение берется из поля town. |
  | houseInt  | Сюда заносится первое число, встреченное в поле house.                                                                                         |

  Если какие-то объекты отсутствуют в адресе, то в результате они тоже не появятся.

  Проиллюстрируем на примере адреса: \\
  *Российская Федерация, город Москва, внутригородская территория поселение Сосенское, посёлок Коммунарка, Бачуринская улица, дом 99Б/12, корпус 5*

  Результат разбора будет таким (для наглядности порядок полей
  подредактирован):
  #+begin_src json
  {
      "country": "Российская Федерация",
      "town": "город Москва",
      "realTown": "посёлок Коммунарка",
      "subtown": [
          {
              "name": "innerTownTerritory",
              "value": "внутригородская территория"
          },
          {
              "name": "colony",
              "value": "поселение Сосенское"
          },
          {
              "name": "settlement",
              "value": "посёлок Коммунарка"
          }
      ],
      "street": "Бачуринская улица",
      "house": [
          "дом 99Б/12",
          "корпус 5"
      ],
      "houseInt": 99
  }
  #+end_src

* Что предполагается дальше?

  В дальнейшем предполагается научить парсер работать со словарями
  названий объектов.

  Создавать такие словари парсер умеет уже сейчас с помощью консольной
  утилиты.

  Словари позволят без ошибок выхватывать адреса из некоторого
  контекста, например:
  : невероятное происшествие по адресу ул.Алексеевская 5

* Замечания

  - Правила для парсера создавались по московским адресам, поэтому не
    все возможные случаи могут быть учтены.

  - Для распознавания адресов построено много правил, но что-то может
    оказаться неучтенным и подлежать доработке.
